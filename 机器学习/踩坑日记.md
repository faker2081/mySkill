---
[toc] 


typora-root-url: ..\typora-user-images


---

# 踩坑日记

## 数据处理

### matplotlib

##### 使用plt.pcolormesh来绘制分类图

```python 
import numpy as np
import pandas as pd
import matplotlib as mpl
import matplotlib.pyplot as plt
from sklearn.tree import DecisionTreeClassifier
 
iris_feature = u'花萼长度', u'花萼宽度', u'花瓣长度', u'花瓣宽度',u'类别'
path = 'iris.data'  # 数据文件路径
data = pd.read_csv(path, header=None)
data.columns=iris_feature
data['类别']=pd.Categorical(data['类别']).codes
x_train = data[['花萼长度','花瓣长度']]
y_train = data['类别']
model = DecisionTreeClassifier(criterion='entropy', min_samples_leaf=3)
model.fit(x_train, y_train)
N, M = 500, 500  # 横纵各采样多少个值
x1_min, x2_min = x_train.min(axis=0)
x1_max, x2_max = x_train.max(axis=0)
t1 = np.linspace(x1_min, x1_max, N)
t2 = np.linspace(x2_min, x2_max, M)
x1, x2 = np.meshgrid(t1, t2)  # 生成网格采样点
x_show = np.stack((x1.flat, x2.flat), axis=1)  # 测试点
y_predict=model.predict(x_show)
 
 
mpl.rcParams['font.sans-serif'] = ['SimHei']
mpl.rcParams['axes.unicode_minus'] = False
cm_light = mpl.colors.ListedColormap(['#A0FFA0', '#FFA0A0', '#A0A0FF'])
cm_dark = mpl.colors.ListedColormap(['g', 'r', 'b'])
plt.xlim(x1_min, x1_max)
plt.ylim(x2_min, x2_max)
plt.pcolormesh(x1, x2, y_predict.reshape(x1.shape), cmap=cm_light)
plt.scatter(x_train['花萼长度'],x_train['花瓣长度'],c=y_train,cmap=cm_dark,marker='o',edgecolors='k')
plt.xlabel('花萼长度')
plt.ylabel('花瓣长度')
plt.title('鸢尾花分类')
plt.grid(True,ls=':')
plt.show()
```

![image-20211107150032533](/image-20211107150032533.png)



接着使用plt.pcolormesh来绘制分类图



来源https://www.kaggle.com/santhraul/methods-to-read-large-datasets

### pandas

#### 字符变量映射数字变量

1. 使用 map 可以实现 Series 的元素级转换。
2. 使用pd.Categorical( list ).codes
   直接得到原始数据的对应的序号列表，通过这样的处理可以将类别信息转化成数值信息 ，这样就可以应用到模型中去了 另外更加详细的功能参考官网。

- 使用 map 可以实现 Series 的元素级转换。

  示例如下：

  ```python
  import pandas as pd
  
  df = pd.DataFrame([['乔峰', 'I', 95, '降龙十八掌', '乞丐'],
                     ['虚竹', 'II', 93, '天上六阳掌', '和尚'],
                     ['段誉', 'II', 92, '六脉神剑', '王侯'],
                     ['包不同', 'V', 65, '胡搅蛮缠', '仆人'],
                     ['康敏', 'X', 10, '惑夫妒人', '坏女人']],
                     columns=['name', 'grade', 'score', 'skill', 'calss'])
  df
  ```

  输出为：

  ![](/image-20211104190818487.png)

   定义一个 grade 的映射字典，转换 grade 列的罗马数字为阿拉伯数字

  ```python
  grade_mapping = {'I': 1, 'II': 2, 'III': 3, 'IV': 4, 'V': 5,
                   'VI': 6, 'VII': 7, 'VIII': 8, 'IX': 9, 'X': 10}
  df.grade = df['grade'].map(grade_mapping)
  df
  ```

  输出如下：

  ![img](https://img2018.cnblogs.com/i-beta/1857668/201911/1857668-20191115145708633-1691782931.png)

   定义一个逆映射

  ```python
  inv_grade_mapping = dict((v, k) for k, v in grade_mapping.items())
  inv_grade_mapping
  ```

  输出如下：

  ![img](https://img2018.cnblogs.com/i-beta/1857668/201911/1857668-20191115145958048-1370805112.png)

   将 df 中的 grade重新转换过为罗马数字：

  ```python
  df.grade = df['grade'].map(inv_grade_mapping)
  df
  ```

  输出如下：

  ![img](https://img2018.cnblogs.com/i-beta/1857668/201911/1857668-20191115150131352-1751501381.png)

- 使用pd.Categorical( list ).codes
  ![image-20211107142527797](/image-20211107142527797.png)

#### 减少不必要的内存开支

pandas在读取数据时给数据分配较多的位数，这会导致不必要的内存占用

```python
%%time

dtypes = {
    "row_id": "int64",
    "timestamp": "int64",
    "user_id": "int32",
    "content_id": "int16",
    "content_type_id": "boolean",
    "task_container_id": "int16",
    "user_answer": "int8",
    "answered_correctly": "int8",
    "prior_question_elapsed_time": "float32", 
    "prior_question_had_explanation": "boolean"
}

data = pd.read_csv("../input/riiid-test-answer-prediction/train.csv", dtype=dtypes)
```

删除不需要的dataframe，释放内存

```python
# free memory
del data
import gc
gc.collect()
```



#### 读取一部分数据

读取前1M行

```python
train_data = pd.read_csv('train.csv', nrows=100000)
```

从中间读入

```python
train_data = pd.read_csv('train.csv', skiprows=range(1, 100001), nrows=100000)
```

##### 删除数据以节省RAM 

```python
import gc
del unwanted_dataframe
gc.collect()
```



### numpy

##### np.meshgird() （笛卡尔积）

```python
#coding:utf-8
import numpy as np
# 坐标向量
a = np.array([1,2,3])
# 坐标向量
b = np.array([7,8])
# 从坐标向量中返回坐标矩阵
# 返回list,有两个元素,第一个元素是X轴的取值,第二个元素是Y轴的取值
res = np.meshgrid(a,b)
#返回结果: [array([ [1,2,3] [1,2,3] ]), array([ [7,7,7] [8,8,8] ])]

```



### 函数参数

###### dataloader

- 在Windows中pytorch中的该方法的num_workwes要设置为0

## kaggle

数据各种读取方式（以及在小内存上训练大数据集）

https://www.kaggle.com/c/tabular-playground-series-oct-2021/discussion/275712

#### LightGBM GPU

如果您想利用 GPU 提供的额外速度，则必须编译并重新安装 LightGBM。如果您不这样做，即使您启用了 GPU，LightGBM 也会简单地恢复使用 CPU。



## 环境配置

#### 超时异常

切换到镜像网站下载

```tex
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 库名
```

```tex
pip install 包名 -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com
这个是豆瓣源
--trusted-host pypi.douban.com 这是为了获得ssl证书的认证，要不然会报错
```



#### 安装txt文档中配置好的库方法

在命令行窗口输入以下命令

```tex
python -m pip install -r requirements_my_project.txt
```

说明

- 版本名和版本号之间是两个`==`；
- 不指定版本的，默认是下载最新版本；
- git是下载github上的库包，并安装；
- 每个库包版本之间都要另起一行

```tex
numpy==1.16.1
pathlib==1.0.1
scandir==1.6
h5py==2.7.1
Keras==2.2.4
opencv-python==4.0.0.21
tensorflow-gpu==1.11.0
plaidml-keras==0.5.0
scikit-image
dlib==19.10.0
tqdm
git+https://www.github.com/keras-team/keras-contrib.git
```

