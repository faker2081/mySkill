### 数学模型概述

#### 基本数据简述



| 变量符号                      | 符号含义                                                     |
| ----------------------------- | ------------------------------------------------------------ |
| $T = [s_1, s_2, ..., s_{m}]$  | 前项$T$ 为任务，后项的为服务组合向量（m个服务），同时也是天牛位置 |
| $C = [T_1, T_2, ...,T_n]$     | 前项$C$ 为任务集合，后项的为任务组合向量（n个任务）          |
| $\vec d =  [d_1,d_2,...,d_m]$ | 为天牛须算法的方向向量（维度和T相同）其中$d_i\in\{-1,0,1\}$  |
| $Q(T)$                        | 任务T的服务质量                                              |
| $Q_{min}$                     | 最小服务质量                                                 |
| $Q_{max}$                     | 最大服务质量                                                 |
| $fit(T)$                      | 任务$T$ 适应度（相对服务质量）                               |
| $Q_{n}(T)$                    | 任务$T$ 的标准服务质量                                       |
| $T_i^l$                       | 任务$T_i$ 左边位置的任务                                     |
| $T_i^r$                       | 任务$T_i$ 右边位置的任务                                     |
| $count(s_i)$                  | 为服务$s_i$的种类数                                          |
| $\lambda$                     | 为变异过程中的缩放系数                                       |
| $distance$                    | 天牛须算法的天牛两须长度                                     |
| $c$                           | $distance$ 和 $\delta$ 的比例系数（大天牛走大步长）          |
| $\delta_i$                    | 步长，与须长成正比。                                         |





#### 基于QoE（用户体验质量）建立评价函数

为了满足用户的需求，本文把一个任务抽象成为一个服务组合$T = [s_1, s_2, ..., s_{m}]$，其中$s_i$ 表示一种类型服务（在本文中，服务类型根据数据集中的服务名进行分类）。评估服务组合T的函数可记为公式 $Q(T) = (RT,L,S,R)$ ，其中RT、L、S、R分别为响应时间（Response Time）、时延（Latency）、成功率（Successability）、可靠性（Reliability）。服务质量计算函数祥见下面的公式（1）
$$
Q = \sum_{i=[RT,L,S,R]}W_i*X_i \tag{1}
$$
为了使计算出来的适应度值可比性更加直观，本文把计算出来的fit值标准化。下面公式（2）是先对Q规格化，其处理后的值记为 $Q_n(x)$ 。公式（3）是对由$Q_n(x)$ 计算出的fit值进行标准化。
$$
Q_n(x) = \left\{

\begin{aligned}

&\text{0}               &&if \ \ Q(T)<Q_{min}\\
&\text{$Q(T)-Q_{min}$}  &&if \ \ Q_{max}>Q(T) > Q_{min} \\
&\text{$Q_{max}$}       &&if \ \ Q(T)>Q_{max}

\end{aligned}

\right. \tag{2}
\\
\\
$$

$$
fit(T) =\frac{Q_n(T)}{Q_{max} - Q_{min}} \tag{3}
$$

在本文中$fit$ 函数的值越大越好，即以下模型的优化目标为最大化$fit$ 函数值。

#### 算法模型

##### 改进思路：

差分算法（DE）与天牛须算法（BAS）的结合思路主要是把天牛须算法融入到差分算法的变异过程中。

融合的思路主要有以下3种：

1.  不使用DE算法中的变异公式，仅通过BAS算法得到变异个体；
2.  先使用BAS算法变异，然后通过DE算法变异公式向种群内的其他个体方向偏移；
3.  先使用DE算法变异公式得到初步变异公式，再通过BAS算法进行二次变异得到最终变异个体。

经试验，思路1的收敛速度和最终结果远远比2,3差，这是由于仅仅依赖天牛须进行变异，个体的搜索空间比较小，从而导致其难以跳出局部最优；思路2在收敛速度和收敛结果上也比思路3差，这是由于先通过天牛须进行变异找到一个较优的位置，然后通过原DE变异公式很容易让其进入到一个更差的位置；思路3，先通过原DE变异公式，让变异个体先向种群其他个体的位置进行偏移，然后通过BAS算法向更优的位置偏移，也就是先让其跳出局部最优，然后个体向更优的位置偏移。

所以本文以下模型全部基于思路3。

#### 基于自适应进化天牛一家算法的web服务组合优化

**差分进化**（DE）算法是一种高效的全局优化算法，同时也是基于群体的启发式搜索算法，种群中的每一个个体对应一个解向量。针对差分进化算法存在的问题，本文考虑将差分进化算法与天牛须算法相结合。

**天牛须搜索**（BAS）算法是一种智能搜索算法，该算法是受到天牛觅食方式的启发。但是该算法的全局搜索能力较差，特别是在面对高维问题时容易陷入局部最优。因此本文将BAS算法和DE算法相结合，增强了天牛须算法的全局搜索能力，同时差分进化算法的局部搜索能力得到了提高。下面是天牛个体的位置更新公式：
$$
BAS(T_i)=\left\{
\begin{aligned}
&T_i + \delta_i * \vec d  && fit(T_i^r)>fit(T_i^l),fit(T_i^r)>fit(T_i)
\\
&T_i                      && fit(T_i)>fit(T_i^l),fit(T_i)>fit(T_i^r)
\\
&T_i - \delta_i * \vec d  &&fit(T_i^l)>fit(T_i^r),fit(T_i^l)>fit(T_i)
\end{aligned}
\right. \tag{4}
$$
因为该问题可以看成是离散的，本文对天牛须算法做了离散化处理，以便于解决该问题。

其中 $T_i$为天牛的位置 ， $\vec d$ 为天牛右须方向，$BAS(T_i)$ 为天牛更新后的位置，他们均为离散变量，其中$T_i$ 可衍生出两侧的两个位置： $T_i^r$ 与 $T_i^l$。其中 $T_i^r$ 与 $T_i^l$ 计算公式如下：
$$
T_i^r = T_i +distance_i * \vec d \tag{5}
$$

$$
T_i^l = T_i - distance_i*\vec d \tag{6}
$$

(5)(6)公式中的$\delta_i $ 为个体每次挪动的步长,大天牛要走大步长，其计算公式为:
$$
\delta_i = distance_i * c \tag{7}
$$
其中c为常数。

(5)(6)公式中的$ \vec d$ 为个体移动的方向。公式（4）（5）（6）保证了个体的局部探索能力。因为在一个个体中，其位置的每个维度的探索空间都不一样，要保证天牛个体随着某一维度探索空间的增大其该维度的须长也要随之增大，但天牛的须长不能过快的增长，同时也要避免因天牛须长度过小导致的其陷入一点无法移动，    我们对天牛须的$distance$ 做了对数化处理，其改进后的公式如下：
$$
distance_i = log(\frac {count(s_i)}{10} + 2) \tag{8}
$$
其中$count(s_i)$ 为服务$s_i$的种类数，也即探索空间大小。该公式保证了其探索空间越大，其中的天牛须长也越大，但是须长的增长速度会趋近于饱和。其中常数2是为了保证distance至少为1，这样避免了天牛在某次不能探索周边位置的情况。



保证了个体的局部探索能力之后，接下来要考虑个体的全局探索能力。自适应变异因子在进化差分算法中具有良好的收敛能力，基于进化差分算法的变异思想，为了使改进后的算法拥有更强的全局探索能力，本文把进化差分算法的自适应变异因子融入其中。改进公式如下：

$$
M_i = BAS(T_{r0} + \lambda*(T_{r1} - T_{r2})) ,r0 \neq r1 \neq r2 \tag{9}
$$
$\lambda$ 为缩放因子，在该文章中其取值为3，其目的是为了让每个个体的探索性更强，不容易陷入局部最优。以上的是3个体变异，还可以是5个体变异，公式如下：
$$
M_i = BAS(T_{r0} + \lambda _0(T_{r1} - T_{r2}))+\lambda_1(T_{r3} - T_{r4}) ,r0 \neq r1 \neq r2 \neq r3 \neq r4\tag{10}
$$

$$

$$













